# 1장. Node.js 아키텍처 (The Core)

Node.js가 어떻게 자바스크립트 코드를 실행하고, 비동기 I/O를 처리하며, 싱글 스레드임에도 높은 성능을 달성하는지를 이해하려면 내부 아키텍처를 알아야 한다. 이 장에서는 Node.js의 핵심 구성 요소들을 하나씩 살펴보며, "왜 이렇게 동작하는가"에 대한 근본적인 답을 찾아본다.

먼저 **V8 엔진**의 동작 원리를 심층적으로 분석한다. V8이 자바스크립트 코드를 어떻게 파싱하고, 바이트코드로 컴파일하며, 런타임에 수집한 타입 정보를 활용하여 기계어 수준의 최적화를 수행하는지 살펴본다. 특히 인라인 캐싱(Inline Caching)이라는 핵심 최적화 기법을 통해, 동적 타입 언어인 자바스크립트가 어떻게 정적 타입 언어에 근접하는 성능을 달성하는지 이해할 수 있다. V8의 동작 원리를 알면 왜 특정 코드 패턴이 빠르고 다른 패턴이 느린지를 근본적인 수준에서 파악할 수 있게 된다.

다음으로 **libuv**를 다룬다. libuv는 Node.js의 비동기 I/O를 담당하는 C 라이브러리로, 파일 시스템 접근, 네트워크 통신, 타이머 등 운영체제와의 모든 상호작용을 처리한다. libuv가 커널의 비동기 API(epoll, kqueue, IOCP 등)와 스레드 풀을 어떻게 조합하여 효율적인 비동기 처리를 구현하는지 알아본다. 이를 통해 Node.js가 싱글 스레드임에도 수천 개의 동시 연결을 처리할 수 있는 이유를 이해할 수 있다.

**이벤트 루프**는 Node.js 비동기 모델의 심장부다. 많은 개발자가 이벤트 루프를 "콜백을 실행하는 무한 루프" 정도로 알고 있지만, 실제로는 여러 단계(phase)로 구성된 정교한 시스템이다. 각 단계가 어떤 종류의 콜백을 처리하고, 어떤 순서로 실행되는지 정확히 이해하면 비동기 코드의 실행 순서를 예측할 수 있게 된다. 또한 "이벤트 루프가 블로킹된다"는 표현의 정확한 의미와, 이를 방지하기 위한 실용적인 전략도 함께 살펴본다.

이어서 **태스크 큐의 우선순위**를 다룬다. `process.nextTick`, `Promise`, `setTimeout`은 모두 비동기적으로 실행되지만, 실행 순서는 서로 다르다. 마이크로태스크와 매크로태스크의 차이, `nextTick` 큐가 가진 특수한 위치, 그리고 이들이 이벤트 루프의 각 단계와 어떻게 상호작용하는지를 명확히 정리한다. 이 지식은 복잡한 비동기 흐름을 디버깅하거나 특정 실행 순서가 보장되어야 하는 코드를 작성할 때 필수적이다.

마지막으로 **실행 컨텍스트와 콜 스택**을 살펴본다. 자바스크립트 코드가 실행될 때 어떻게 실행 컨텍스트가 생성되고 콜 스택에 쌓이는지, 그리고 비동기 콜백이 실행될 때 이전 컨텍스트와 어떤 관계를 갖는지 이해한다. 이는 에러 스택 트레이스를 읽고 디버깅하는 능력, 그리고 클로저와 스코프를 정확히 이해하는 데 기반이 된다.

이 장을 마치면 Node.js가 자바스크립트 코드를 어떻게 실행하고, 비동기 작업을 어떻게 처리하며, 이벤트 기반 아키텍처가 어떻게 동작하는지에 대한 전체적인 그림을 갖게 될 것이다. 이러한 이해는 이후 장에서 다룰 모듈 시스템, 메모리 관리, 네트워킹 등 모든 주제의 기반이 된다.
